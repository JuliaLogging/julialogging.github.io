var documenterSearchIndex = {"docs":
[{"location":"how-to/tee/#Send-messages-to-multiple-locations","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"","category":"section"},{"location":"how-to/tee/","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"In this tutorial we will see how log messages can be sent to multiple locations at the same time. In e.g. Working with loggers and How to log to a file we saw some alternative loggers (NullLogger, FileLogger, etc.) and how to use them. However, in those examples we made so that messages were sent only to the new logger. The LoggingExtras.jl package implement a logger for this purpose, the TeeLogger. The name is inspired by the shell utility tee which writes command output to both standard out and a file.","category":"page"},{"location":"how-to/tee/","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"A very common logging setup is to write logs to both stderr (as the default logger does) and a file. Here is how we can do that using a TeeLogger, a FileLogger, and the default ConsoleLogger:","category":"page"},{"location":"how-to/tee/","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"using Logging, LoggingExtras\n\nlogger = TeeLogger(\n    global_logger(),          # Current global logger (stderr)\n    FileLogger(\"logfile.log\") # FileLogger writing to logfile.log\n)\n\nnothing # hide","category":"page"},{"location":"how-to/tee/","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"When using this logger every message will be routed to both the default logger and to the file. Together with log message filtering it is possible to create arbitrary log message routing since all the loggers compose nicely and they can be nested. This is described more in How to filter messages, but a short example of this is given below.","category":"page"},{"location":"how-to/tee/","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"Here is a logger that writes messages to three loggers:","category":"page"},{"location":"how-to/tee/","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"The default global logger (stderr),\nA MinLevelLogger accepting any message with level >= Info and writing them to a file \"logfile.log\" using a FileLogger,\nA MinLevelLogger accepting any message with level >= Debug and writing them to a file \"debug.log\" using a FileLogger.","category":"page"},{"location":"how-to/tee/","page":"Send messages to multiple locations","title":"Send messages to multiple locations","text":"using Logging, LoggingExtras\n\nlogger = TeeLogger(\n    # Current global logger (stderr)\n    global_logger(),\n    # Accept any messages with level >= Info\n    MinLevelLogger(\n        FileLogger(\"logfile.log\"),\n        Logging.Info\n    ),\n    # Accept any messages with level >= Debug\n    MinLevelLogger(\n        FileLogger(\"debug.log\"),\n        Logging.Debug,\n    ),\n)\n\nnothing # hide","category":"page"},{"location":"reference/logroller/#LogRoller.jl","page":"LogRoller.jl","title":"LogRoller.jl","text":"","category":"section"},{"location":"reference/logroller/","page":"LogRoller.jl","title":"LogRoller.jl","text":"Modules = [LogRoller]","category":"page"},{"location":"reference/logroller/#LogRoller.IndexedLogEntry","page":"LogRoller.jl","title":"LogRoller.IndexedLogEntry","text":"IndexedLogEntry represents a log entry as a dictionary and its indexable attributes in a form that is useful to a logging sink.\n\nThe index part contains metadata that are to be indexed. Event metadata consists of attributes like level, module, filepath, line, job id, process id, user id, etc. It also includes application specific keywords that the originating piece of code wishes to index.\n\nKeywords that should be considered as metadata are indicated via the indexable constructor parameter.\n\nWhat metadata can be indexed depends on the type of sink and whether it has support to index certain types of attributes. Attributes that the sink can not index are made part of the message itself for storage.\n\nThe message part can contain the following keys unless they are empty:\n\nmetadata: event metadata that could not be indexed\nmessage: the log message string\nkeywords: any keywords provided\n\nConstructor parameters:\n\nlog: Named tuple containing args to the handle_message method, e.g.: (level, message, _module, group, id, file, line, kwargs)\nindexable: list of names from log and log.kwargs that should be included in the index\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#LogRoller.LogEntrySerialization","page":"LogRoller.jl","title":"LogRoller.LogEntrySerialization","text":"Custom JSON serializer for log entries. Handles Module types for now, more can be added later.\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#LogRoller.RollingFileWriter","page":"LogRoller.jl","title":"LogRoller.RollingFileWriter","text":"A file writer that implements the IO interface, but only provides write methods.\n\nConstructor parameters:\n\nfilename: name (including path) of file to log into\nsizelimit: size of file (in bytes) after which the file should be rotated\nnfiles: number of rotated files to maintain\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#LogRoller.RollingLogger","page":"LogRoller.jl","title":"LogRoller.RollingLogger","text":"RollingLogger(filename, sizelimit, nfiles, minlevel=Info; timestampidentifier::Symbol=:time, format::Symbol=:console) Log into a log file. Rotate log file based on file size. Compress rotated logs.\n\nLogs can be formatted as JSON by setting the optional keyword argument format to :json. A JSON formatted log entry is a JSON object. It should have these keys (unless they are empty): The message part can contain the following keys unless they are empty:\n\nmetadata: event metadata e.g. timestamp, line, filename, ...\nmessage: the log message string\nkeywords: any keywords provided\n\n\n\n\n\n","category":"type"},{"location":"reference/logroller/#Base.close-Tuple{LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"Base.close","text":"Close any open file handle and streams. A closed object must not be used again.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#Base.close-Tuple{LogRoller.RollingLogger}","page":"LogRoller.jl","title":"Base.close","text":"Close any open file handle and streams. A closed object must not be used again.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#Base.write-Tuple{LogRoller.RollingFileWriter, UInt8}","page":"LogRoller.jl","title":"Base.write","text":"Write into the underlying stream, rolling over as and when necessary.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.RollingFileWriterTee","page":"LogRoller.jl","title":"LogRoller.RollingFileWriterTee","text":"Tees raw log entries made a RollingFileWriter on to a provided Julia AbstractLogger.\n\nEach line of text is taken as a single log message.\n\nAll log entries are made with the same log level, which can be provided during construction. It leaves further examination/parsing of log messages (to extract parameters, or detect exact log levels) to the downstream logger.\n\n\n\n\n\n","category":"function"},{"location":"reference/logroller/#LogRoller.postrotate-Tuple{Function, LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"LogRoller.postrotate","text":"Register a function to be called with the rotated file name just after the current log file is rotated. The file name of the rotated file is passed as an argument. The function is blocking and so any lengthy operation that needs to be done should be done asynchronously.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.postrotate-Tuple{Function, LogRoller.RollingLogger}","page":"LogRoller.jl","title":"LogRoller.postrotate","text":"Register a function to be called with the rotated file name just after the current log file is rotated. The file name of the rotated file is passed as an argument. The function is blocking and so any lengthy operation that needs to be done should be done asynchronously.\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.rotate_file-Tuple{LogRoller.RollingFileWriter}","page":"LogRoller.jl","title":"LogRoller.rotate_file","text":"Rotate files as below with increasing age:     - <filename> : active file     - <filename>1.gz : last rotated file     - <filename>2.gz : previous <filename>1.gz rotated to <filename>2.gz     - <filename>3.gz : previous <filename>2.gz rotated to <filename>3.gz     - ...     - <filename>n.gz : last rotated file is discarded when rotated\n\n\n\n\n\n","category":"method"},{"location":"reference/logroller/#LogRoller.tee-Tuple{LogRoller.RollingFileWriter, Base.CoreLogging.AbstractLogger, Base.CoreLogging.LogLevel}","page":"LogRoller.jl","title":"LogRoller.tee","text":"Tee all lines to the provided logger\n\n\n\n\n\n","category":"method"},{"location":"reference/sysloglogging/#SyslogLogging.jl","page":"SyslogLogging.jl","title":"SyslogLogging.jl","text":"","category":"section"},{"location":"reference/sysloglogging/","page":"SyslogLogging.jl","title":"SyslogLogging.jl","text":"Modules = [SyslogLogging]","category":"page"},{"location":"reference/sysloglogging/#SyslogLogging.SyslogLogger","page":"SyslogLogging.jl","title":"SyslogLogging.SyslogLogger","text":"Logs messages to a syslog facility.\n\n\n\n\n\n","category":"type"},{"location":"package-overview/#Logging-package-overview","page":"Logging package overview","title":"Logging package overview","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"This section contains an overview of the many packages that are related to logging in Julia. Most of the packages integrate with the standard logging frontend macros @debug, @info, @warn, and @error from Base and with the abstractions provided by the Logging.jl standard library.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"note: Note\nIf some logging-related package is missing from the list below don't hesitate to contribute by adding it!","category":"page"},{"location":"package-overview/#logging-overview","page":"Logging package overview","title":"Logging.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The Logging stdlib provides much of the logging infrastructure which most of the other logging packages build upon. Among other things, Logging provides global_logger and with_logger for setting the global/local logger, the AbstractLogger interface, and three loggers:","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"ConsoleLogger: default logger in the Julia REPL\nSimpleLogger: a basic version of ConsoleLogger\nNullLogger: logger equivalent of /dev/null.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"Functionality from Logging is used in most of the tutorials and how-to's in this documentation.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the Logging API reference for details.","category":"page"},{"location":"package-overview/#loggingextras-overview","page":"Logging package overview","title":"LoggingExtras.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The LoggingExtras package provides many essential extensions to the Logging stdlib. For example loggers for message filtering: MinLevelLogger, EarlyFilteredLogger, and ActiveFilteredLogger; a TransformerLogger for arbitrary message transformations; a TeeLogger for message routing; and three different logger sinks: FileLogger for logging to files on disk, FormatLogger for customizing the logging output formatting, and DatetimeRotatingFileLogger for logging to files on disk that rotates based on the date. Functionality from LoggingExtras is used in most how-to guides so refer to those for examples.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the LoggingExtras API reference for details.","category":"page"},{"location":"package-overview/#loggingformats-overview","page":"Logging package overview","title":"LoggingFormats.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The LoggingFormats package provide some predefined logging formats to be used with FormatLogger, DatetimeRotatingFileLogger from the LoggingExtras.jl package:","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"LoggingFormats.JSON: output log messages serialized to JSON,\nLoggingFormats.LogFmt: output log messages formatted as logfmt,\nLoggingFormats.Truncated: similar formatting as ConsoleLogger, but with long messages truncated.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the LoggingFormats API reference for details.","category":"page"},{"location":"package-overview/#terminalloggers-overview","page":"Logging package overview","title":"TerminalLoggers.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The TerminalLoggers package provides the TerminalLogger which is a more advanced terminal-based pretty printing of log records. In particular it supports Markdown formatting of log messages and progress bars (built on top of the ProgressLogging package).","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the TerminalLoggers API reference for details.","category":"page"},{"location":"package-overview/#progresslogging-overview","page":"Logging package overview","title":"ProgressLogging.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The ProgressLogging package provides some convenient frontend macros including @progress which makes it easy to emit log records tracking the progress of looping constructs.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the ProgressLogging API reference for details.","category":"page"},{"location":"package-overview/#logroller-overview","page":"Logging package overview","title":"LogRoller.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The LogRoller package provide functionality for rotating log files when they hit a certain size limit. In particular the IO RollingFileWriter (which can be combined with other loggers) and also the RollingLogger.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the LogRoller API reference for details.","category":"page"},{"location":"package-overview/#logroller-overview-2","page":"Logging package overview","title":"SyslogLogging.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The SyslogLogging package provides the SyslogLogger which writes messages to syslog.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the SyslogLogging API reference for details.","category":"page"},{"location":"package-overview/#logging2-overview","page":"Logging package overview","title":"Logging2.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The Logging2 package provides utilities for redirecting stdout and stderr output to the logging system.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the Logging2 API reference for details.","category":"page"},{"location":"package-overview/#tensorboardlogger-overview","page":"Logging package overview","title":"TensorBoardLogger.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The TensorBoardLogger package can log structured numeric data to TensorBoard as a backend.","category":"page"},{"location":"package-overview/#lokilogger-overview","page":"Logging package overview","title":"LokiLogger.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The LokiLogger package provides the LokiLogger.Logger logger which sends the log messages over HTTP to a Grafana Loki server.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the LokiLogger API reference for details.","category":"page"},{"location":"package-overview/#logcompose-overview","page":"Logging package overview","title":"LogCompose.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The LogCompose package provides declarative logger configuration and an associated .toml file format.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the LogCompose API reference for details.","category":"page"},{"location":"package-overview/#miniloggers-overview","page":"Logging package overview","title":"MiniLoggers.jl","text":"","category":"section"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"(Image: ) (Image: )","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"The MiniLoggers package provides Julia logger with minimal setup and simple yet powerful format of logging strings. It allows to build custom and compact logging, which supports coloring, output to external files, timestamps and many more.","category":"page"},{"location":"package-overview/","page":"Logging package overview","title":"Logging package overview","text":"See the MiniLoggers API reference for details.","category":"page"},{"location":"how-to/rotate-log-files/#How-to-rotate-log-files","page":"How to rotate log files","title":"How to rotate log files","text":"","category":"section"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"Log rotation is common for long running applications such as e.g. a webserver, see for example logrotate for Linux systems. Log rotation means that the logfile is swapped according to some criterion. Usually a logfile is rotated based on the date, for example daily or weekly, or based on file size, for example to keep the individual files below 10MB.","category":"page"},{"location":"how-to/rotate-log-files/#Date-based-log-rotation","page":"How to rotate log files","title":"Date based log rotation","text":"","category":"section"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"The LoggingExtras.jl package implements the DatetimeRotatingFileLogger which, as the name suggests, is a logger for date/time based log rotation. The frequency of log rotation is determined based on the input filename pattern in the form of a dateformat (see documentation for Dates.DateFormat and dateformat\"...\").","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"Let's look at an initial example:","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"using Logging, LoggingExtras\n\n# Directory for our log files\nlogdir = joinpath(@__DIR__, \"logs\")\nlogdir = joinpath(mktempdir(), \"logs\") # hide\nmkpath(logdir)\n\n# Filename pattern (see note below about character escaping)\nfilename_pattern = raw\"yyyy-mm-dd-\\w\\e\\b\\s\\e\\r\\v\\e\\r.\\l\\o\\g\"\n\n# Create the logger\nlogger = DatetimeRotatingFileLogger(logdir, filename_pattern)\n\nold_global_logger = global_logger() # hide\n# Install the logger globally\nglobal_logger(logger)\nglobal_logger(old_global_logger) # hide\nrm(logdir; recursive=true, force=true) # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"This is a logger that will rotate the log file every day, since \"day\" is the smallest datetime unit in the filename pattern.","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"note: Note\nNote that all characters in the filename pattern that should not be part of of the datetime pattern are escaped. Without this these characters would also be interpreted by Dates.DateFormat. Technically not all characters need to be escaped, for example w doesn't have a meaning, but it is safest to escape all characters like in the example above.","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"Eventually, after some days of logging, we would end up with the following files in our log directory:","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"$ ls logs/\n2021-11-12-webserver.log\n2021-11-13-webserver.log\n2021-11-14-webserver.log\n2021-11-15-webserver.log","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"Let's now improve the logger by adding two features that are commonly used in logrotate: file compression and file retention policy. Log files are usually quite compressible and adding compression could save us some space. A file retention policy let us keep log files for a fixed number of days, for example 30, and then automatically delete them. Support for compression and retention policies are not built-in, but there are external packages that we can use for these purposes and implement this functionality in a callback function using the rotation_callback keyword argument. The DatetimeRotatingFileLogger calls this function every time it rotates the log file. The only argument to the function is the \"old\" file.","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"For compression we will use gzip, through Gzip_jll:","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"using Gzip_jll\n\nfunction logger_callback(file)\n    # Compress the file\n    Gzip_jll.gzip() do gzip\n        run(`$(gzip) $(file)`)\n    end\nend\nnothing # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"For the file retention policy we will use an NFileCache from the FilesystemDatastructures package. Here we create a file cache that keeps 30 files:","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"using FilesystemDatastructures\n\n# Create a file cache that keeps 30 files\nfc = NFileCache(logdir, 30, DiscardLRU();\n                # Make sure only files ending with \"webserver.log.gz\" are included\n                predicate = x -> endswith(x, r\"webserver\\.log\\.gz\")\n)\nnothing # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"Now we just have to modify the callback above to add rotated and compressed files to the cache:","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"function logger_callback(file)\n    # Compress the file\n    Gzip_jll.gzip() do gzip\n        run(`$(gzip) $(file)`)\n    end\n    # Add the compressed file to the cache (gzip adds the .gz extension)\n    FilesystemDatastructures.add!(fc, file * \".gz\")\nend\nnothing # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"When the 31th file is added to the cache the oldest file will automatically be deleted to make room for the new file. Inspecting the log directory after letting the application run for some time gives us:","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"$ ls logs/\n2021-11-20-webserver.log.gz\n2021-11-21-webserver.log.gz\n2021-11-22-webserver.log.gz\n[...]\n2021-12-17-webserver.log.gz\n2021-12-18-webserver.log.gz\n2021-12-19-webserver.log.gz\n2021-12-20-webserver.log","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"30 compressed files, managed by the cache, and one \"active\" file yet to be compressed and added to the cache.","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"Here is the complete example:","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"using Logging, LoggingExtras, Gzip_jll, FilesystemDatastructures\n\n# Directory for our log files\nlogdir = joinpath(@__DIR__, \"logs\")\nlogdir = joinpath(mktempdir(), \"logs\") # hide\nmkpath(logdir)\n\n# Filename pattern\nfilename_pattern = raw\"yyyy-mm-dd-\\w\\e\\b\\s\\e\\r\\v\\e\\r.\\l\\o\\g\"\n\n# File cache that keeps 30 files\nfc = NFileCache(logdir, 30, DiscardLRU();\n                # Make sure only files ending with \"webserver.log.gz\" are included\n                predicate = x -> endswith(x, r\"webserver\\.log\\.gz\")\n)\n\n# Callback function for compression and adding to cache\nfunction logger_callback(file)\n    # Compress the file\n    Gzip_jll.gzip() do gzip\n        run(`$(gzip) $(file)`)\n    end\n    # Add the compressed file to the cache (gzip adds the .gz extension)\n    FilesystemDatastructures.add!(fc, file * \".gz\")\nend\n\n# Create the logger\nlogger = DatetimeRotatingFileLogger(\n             logdir, filename_pattern;\n             rotation_callback = logger_callback,\n)\n\nold_global_logger = global_logger() # hide\n# Install the logger globally\nglobal_logger(logger)\nglobal_logger(old_global_logger) # hide\nrm(logdir; recursive=true, force=true) # hide","category":"page"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"note: Note\nThe setup above is very similar to the logging setup used by Julia's package servers, see JuliaPackaging/PkgServer.jl:bin/run_server.jl","category":"page"},{"location":"how-to/rotate-log-files/#Filesize-based-log-rotation","page":"How to rotate log files","title":"Filesize based log rotation","text":"","category":"section"},{"location":"how-to/rotate-log-files/","page":"How to rotate log files","title":"How to rotate log files","text":"For filesize based rotation, e.g. file rotation when the filesize reaches a specific threshold, checkout the LogRoller.jl package.","category":"page"},{"location":"reference/logging2/#Logging2.jl","page":"Logging2.jl","title":"Logging2.jl","text":"","category":"section"},{"location":"reference/logging2/","page":"Logging2.jl","title":"Logging2.jl","text":"Modules = [Logging2]","category":"page"},{"location":"reference/logging2/#Logging2.LineBufferedIO","page":"Logging2.jl","title":"Logging2.LineBufferedIO","text":"LineBufferedIO(dest::IO)\n\nA thread safe line buffered IO wrapper which buffers writes until a full line (delimited by '\\n') is received. Full lines are written to the downstream dest IO.\n\nTo ensure that the tail of the stream is written (even without a trailing '\\n'), be sure to call close().\n\n\n\n\n\n","category":"type"},{"location":"reference/logging2/#Logging2.LoggingStream","page":"Logging2.jl","title":"Logging2.LoggingStream","text":"LoggingStream(logger; level, id)\n\nAn IO object which collects incoming calls to write and writes them to the Julia logging system via logger. Most useful when combined with LineBufferedIO. The standard logging _id field will be set to id.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging2/#Base.redirect_stderr","page":"Logging2.jl","title":"Base.redirect_stderr","text":"redirect_stderr(f::Function, logger::AbstractLogger)\n\nRedirect the global stderr stream to logger, with each line becoming a log event during the execution of the function f.\n\nSee redirect_stdout for examples and additional information.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging2/#Base.redirect_stdout","page":"Logging2.jl","title":"Base.redirect_stdout","text":"redirect_stdout(f::Function, logger::AbstractLogger)\n\nRedirect the global stdout stream to logger, with each line becoming a log event during the execution of the function f.\n\nnote: Note\nIn contrast to the dynamic scope of the usual logging system frontend (@info, etc), stdout is a global object so it's not entirely clear that we can collect the logger from the current dynamic scope where Base.stdout is looked up, and efficiently use it.In particular, some particular uses of stdout require it to have an operating system primitive like a Pipe backing the object. However not all uses require this, and it may be possible to improve the situation in the future.\n\nExamples\n\nHere's how you use redirect_stdout in structured concurrency style:\n\nredirect_stdout(current_logger()) do\n    println(\"Hi\")\n    run(`ls`)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/terminalloggers/#TerminalLoggers.jl","page":"TerminalLoggers.jl","title":"TerminalLoggers.jl","text":"","category":"section"},{"location":"reference/terminalloggers/","page":"TerminalLoggers.jl","title":"TerminalLoggers.jl","text":"Modules = [TerminalLoggers]","category":"page"},{"location":"reference/terminalloggers/#TerminalLoggers.TerminalLoggers","page":"TerminalLoggers.jl","title":"TerminalLoggers.TerminalLoggers","text":"TerminalLoggers\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov)\n\nTerminalLoggers provides a logger type TerminalLogger which can format your log messages in a richer way than the default ConsoleLogger which comes with the julia standard Logging library.\n\nRead the documentation for more information.\n\n\n\n\n\n","category":"module"},{"location":"reference/terminalloggers/#TerminalLoggers.StickyMessages","page":"TerminalLoggers.jl","title":"TerminalLoggers.StickyMessages","text":"StickyMessages(io::IO; ansi_codes=io isa Base.TTY && \n               (!Sys.iswindows() || VERSION >= v\"1.5.3\"))\n\nA StickyMessages type manages the display of a set of persistent \"sticky\" messages in a terminal. That is, messages which are not part of the normal scrolling output. Each message is identified by a label and may may be added to the set using push!(messages, label=>msg), and removed using pop!(messages, label), or empty!().\n\nOnly a single StickyMessages object should be associated with a given TTY, as the object manipulates the terminal scrolling region.\n\n\n\n\n\n","category":"type"},{"location":"reference/terminalloggers/#TerminalLoggers.TerminalLogger","page":"TerminalLoggers.jl","title":"TerminalLoggers.TerminalLogger","text":"TerminalLogger(stream=stderr, min_level=LogLevel(-1); meta_formatter=default_metafmt,\n               show_limited=true, right_justify=0)\n\nLogger with formatting optimized for interactive readability in a text console (for example, the Julia REPL). This is an enhanced version of the terminal logger Logging.ConsoleLogger which comes installed with Julia by default.\n\nLog levels less than min_level are filtered out.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\n\n\n\n\n\n","category":"type"},{"location":"tutorials/working-with-loggers/#Working-with-loggers","page":"Working with loggers","title":"Working with loggers","text":"","category":"section"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"tip: Tip\nIt is a good idea to follow along by copy-pasting the code snippets into a Julia REPL!","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"In this tutorial we will learn how to work with loggers, i.e. the backends that receives and handles the log messages emitted by @info and friends (see Logging basics).","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"The default logger in Julia is a ConsoleLogger that prints log messages to the terminal (specifically it prints to stderr).","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"@info \"Hello default ConsoleLogger!\"","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"The ConsoleLogger is just one implementation of a logger backend but there are many other backends for various purposes, see for example the Logging package overview. In this tutorial we will only try out the loggers that are defined in the Logging.jl standard library, but the functions for working with loggers are the same no matter which logger implementation you use.","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"The global_logger function can be used to get or set the global logger:","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"using Logging\nglobal_logger() = current_logger() # hide\nglobal_logger() |> typeof","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"The current global logger is inherited by any spawned tasks so if you want to set a custom logger for your program it is usually enough to update the global logger. Here is an example of how to set the global logger to a NullLogger to silence all log messages:","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"using Logging\nlogger = NullLogger();\nold_logger = global_logger(logger); # save the old logger\nwith_logger(NullLogger()) do # hide\n@info \"This message goes to the new global NullLogger!\"\nend # hide\nglobal_logger(old_logger); # reset to the old logger\n@info \"This message goes to the old logger again!\"","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"As you can see in the example, the global_logger function returns the old logger when a new one is set and we then reset the global logger to the old one. For a program/application this is usually all you need – you construct a logger, or a combination of loggers, and set the global logger to this one.","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"With the with_logger function it is possible to change the logger for a specific task.","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"using Logging\nlogger = NullLogger();\nwith_logger(logger) do\n    @info \"This message goes to the temporary logger!\"\nend\n@info \"Now the logger is back to normal.\"","category":"page"},{"location":"tutorials/working-with-loggers/","page":"Working with loggers","title":"Working with loggers","text":"As you can see, after the call to with_logger the logger state is unchanged and the log message is displayed as usual.","category":"page"},{"location":"reference/logcompose/#LogCompose.jl","page":"LogCompose.jl","title":"LogCompose.jl","text":"","category":"section"},{"location":"reference/logcompose/","page":"LogCompose.jl","title":"LogCompose.jl","text":"Modules = [LogCompose]","category":"page"},{"location":"reference/logging/#Logging.jl","page":"Logging.jl","title":"Logging.jl","text":"","category":"section"},{"location":"reference/logging/#General-usage","page":"Logging.jl","title":"General usage","text":"","category":"section"},{"location":"reference/logging/","page":"Logging.jl","title":"Logging.jl","text":"Logging.@logmsg\nLogging.LogLevel\nLogging.Debug\nLogging.Info\nLogging.Warn\nLogging.Error\nLogging.global_logger\nLogging.current_logger\nLogging.with_logger\nLogging.ConsoleLogger\nLogging.SimpleLogger\nLogging.NullLogger","category":"page"},{"location":"reference/logging/#Logging.@logmsg","page":"Logging.jl","title":"Logging.@logmsg","text":"@debug message  [key=value | value ...]\n@info  message  [key=value | value ...]\n@warn  message  [key=value | value ...]\n@error message  [key=value | value ...]\n\n@logmsg level message [key=value | value ...]\n\nCreate a log record with an informational message.  For convenience, four logging macros @debug, @info, @warn and @error are defined which log at the standard severity levels Debug, Info, Warn and Error.  @logmsg allows level to be set programmatically to any LogLevel or custom log level types.\n\nmessage should be an expression which evaluates to a string which is a human readable description of the log event.  By convention, this string will be formatted as markdown when presented.\n\nThe optional list of key=value pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record.  If only a value expression is supplied, a key representing the expression will be generated using Symbol. For example, x becomes x=x, and foo(10) becomes Symbol(\"foo(10)\")=foo(10).  For splatting a list of key value pairs, use the normal splatting syntax, @info \"blah\" kws....\n\nThere are some keys which allow automatically generated log data to be overridden:\n\n_module=mod can be used to specify a different originating module from the source location of the message.\n_group=symbol can be used to override the message group (this is normally derived from the base name of the source file).\n_id=symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\n_file=string and _line=integer can be used to override the apparent source location of a log message.\n\nThere's also some key value pairs which have conventional meaning:\n\nmaxlog=integer should be used as a hint to the backend that the message should be displayed no more than maxlog times.\nexception=ex should be used to transport an exception with a log message, often used with @error. An associated backtrace bt may be attached using the tuple exception=(ex,bt).\n\nExamples\n\n@debug \"Verbose debugging information.  Invisible by default\"\n@info  \"An informational message\"\n@warn  \"Something was odd.  You should pay attention\"\n@error \"A non fatal error occurred\"\n\nx = 10\n@info \"Some variables attached to the message\" x a=42.0\n\n@debug begin\n    sA = sum(A)\n    \"sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true\"\nend\n\nfor i=1:10000\n    @info \"With the default backend, you will only see (i = $i) ten times\"  maxlog=10\n    @debug \"Algorithm1\" i progress=i/10000\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/logging/#Logging.LogLevel","page":"Logging.jl","title":"Logging.LogLevel","text":"LogLevel(level)\n\nSeverity/verbosity of a log record.\n\nThe log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.\n\nExamples\n\njulia> Logging.LogLevel(0) == Logging.Info\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.Debug","page":"Logging.jl","title":"Logging.Debug","text":"Debug\n\nAlias for LogLevel(-1000).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.Info","page":"Logging.jl","title":"Logging.Info","text":"Info\n\nAlias for LogLevel(0).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.Warn","page":"Logging.jl","title":"Logging.Warn","text":"Warn\n\nAlias for LogLevel(1000).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.Error","page":"Logging.jl","title":"Logging.Error","text":"Error\n\nAlias for LogLevel(2000).\n\n\n\n\n\n","category":"constant"},{"location":"reference/logging/#Logging.global_logger","page":"Logging.jl","title":"Logging.global_logger","text":"global_logger()\n\nReturn the global logger, used to receive messages when no specific logger exists for the current task.\n\nglobal_logger(logger)\n\nSet the global logger to logger, and return the previous global logger.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.current_logger","page":"Logging.jl","title":"Logging.current_logger","text":"current_logger()\n\nReturn the logger for the current task, or the global logger if none is attached to the task.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.with_logger","page":"Logging.jl","title":"Logging.with_logger","text":"with_logger(function, logger)\n\nExecute function, directing all log messages to logger.\n\nExample\n\nfunction test(x)\n    @info \"x = $x\"\nend\n\nwith_logger(logger) do\n    test(1)\n    test([1,2])\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.ConsoleLogger","page":"Logging.jl","title":"Logging.ConsoleLogger","text":"ConsoleLogger([stream,] min_level=Info; meta_formatter=default_metafmt,\n              show_limited=true, right_justify=0)\n\nLogger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.\n\nLog levels less than min_level are filtered out.\n\nMessage formatting can be controlled by setting keyword arguments:\n\nmeta_formatter is a function which takes the log event metadata (level, _module, group, id, file, line) and returns a color (as would be passed to printstyled), prefix and suffix for the log message.  The default is to prefix with the log level and a suffix containing the module, file and line location.\nshow_limited limits the printing of large data structures to something which can fit on the screen by setting the :limit IOContext key during formatting.\nright_justify is the integer column which log metadata is right justified at. The default is zero (metadata goes on its own line).\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.SimpleLogger","page":"Logging.jl","title":"Logging.SimpleLogger","text":"SimpleLogger([stream,] min_level=Info)\n\nSimplistic logger for logging all messages with level greater than or equal to min_level to stream. If stream is closed then messages with log level greater or equal to Warn will be logged to stderr and below to stdout.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.NullLogger","page":"Logging.jl","title":"Logging.NullLogger","text":"NullLogger()\n\nLogger which disables all messages and produces no output - the logger equivalent of /dev/null.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging-interface","page":"Logging.jl","title":"Logging interface","text":"","category":"section"},{"location":"reference/logging/","page":"Logging.jl","title":"Logging.jl","text":"Logging.AbstractLogger\nLogging.min_enabled_level\nLogging.shouldlog\nLogging.catch_exceptions\nLogging.handle_message","category":"page"},{"location":"reference/logging/#Logging.AbstractLogger","page":"Logging.jl","title":"Logging.AbstractLogger","text":"A logger controls how log records are filtered and dispatched.  When a log record is generated, the logger is the first piece of user configurable code which gets to inspect the record and decide what to do with it.\n\n\n\n\n\n","category":"type"},{"location":"reference/logging/#Logging.min_enabled_level","page":"Logging.jl","title":"Logging.min_enabled_level","text":"min_enabled_level(logger)\n\nReturn the minimum enabled level for logger for early filtering.  That is, the log level below or equal to which all messages are filtered.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.shouldlog","page":"Logging.jl","title":"Logging.shouldlog","text":"shouldlog(logger, level, _module, group, id)\n\nReturn true when logger accepts a message at level, generated for _module, group and with unique log identifier id.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.catch_exceptions","page":"Logging.jl","title":"Logging.catch_exceptions","text":"catch_exceptions(logger)\n\nReturn true if the logger should catch exceptions which happen during log record construction.  By default, messages are caught\n\nBy default all exceptions are caught to prevent log message generation from crashing the program.  This lets users confidently toggle little-used functionality - such as debug logging - in a production system.\n\nIf you want to use logging as an audit trail you should disable this for your logger type.\n\n\n\n\n\n","category":"function"},{"location":"reference/logging/#Logging.handle_message","page":"Logging.jl","title":"Logging.handle_message","text":"handle_message(logger, level, message, _module, group, id, file, line; key1=val1, ...)\n\nLog a message to logger at level.  The logical location at which the message was generated is given by module _module and group; the source location by file and line. id is an arbitrary unique value (typically a Symbol) to be used as a key to identify the log statement when filtering.\n\n\n\n\n\n","category":"function"},{"location":"how-to/filter-messages/#How-to-filter-messages","page":"How to filter messages","title":"How to filter messages","text":"","category":"section"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"In this tutorial we will see how to filter messages based on the metadata (level, module, etc.) and the content of log messages. In How to enable @debug messages and Send messages to multiple locations there were examples of how to filter messages based on the log level, but not based on other things.","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"Messages can be filtered in two stages during the logging system message plumbing. In the first stage only the metadata is known (level, module, group, and id). In particular the message string itself has not been constructed yet. Filtering at this stage can be more efficient if the log message creation is expensive. For example, in","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"@info \"The value of some_expensive_call is: $(some_expensive_call(args...))\"","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"the call to some_expensive_call has not happened yet in the early stage. Messages can also be filtered later, when more information is available, such as the full message string, file and line, and any keyword arguments.","category":"page"},{"location":"how-to/filter-messages/#Early-filtering-using-EarlyFilteredLogger","page":"How to filter messages","title":"Early filtering using EarlyFilteredLogger","text":"","category":"section"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"Filtering in the early stage can be done with an EarlyFilteredLogger from the LoggingExtras.jl package. The EarlyFilteredLogger takes a predicate function and a logger as input arguments. If the predicate returns true the message is passed on to the wrapped logger, otherwise it is ignored. The predicate function is passed a named tuple, see LoggingExtras.shouldlog_args, as the only input.","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"Here is an example of a logger that only accept (i) messages that are of Logging.Info level (Logging.Info <= level < Logging.Warn) and (ii) messages coming from the Foo module:","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"using Logging, LoggingExtras\n\n# Define the Foo module\nmodule Foo\n    info() = @info \"Information from Foo\"\n    warn() = @warn \"Warning from Foo\"\nend\nusing .Foo\n\nbegin # hide\n# Create the logger\nglobal_logger() = current_logger() # hide\nlogger = EarlyFilteredLogger(global_logger()) do args\n    r = Logging.Info <= args.level < Logging.Warn && args._module === Foo\n    return r\nend\n\n# Test it\nwith_logger(logger) do\n    @info \"Information from Main\"\n    @warn \"Warning from Main\"\n    Foo.info()\n    Foo.warn()\nend\nend # hide","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"As you can see, the only message that wasn't dropped by the filter is the @info message from the Foo module!","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"note: Note\nThe MinLevelLogger is just a special case of an EarlyFilteredLogger that only checks that the log level of the message is higher than the configured one.","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"Together with the TeeLogger we can now create arbitrary routing for the messages. Here is a more complicated example:","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"using Logging, LoggingExtras\n\nmodule WebServer end # hide\nlogger = TeeLogger(\n    global_logger(),\n    EarlyFilteredLogger(\n        args -> args._module === WebServer,\n        TeeLogger(\n            EarlyFilteredLogger(\n                args -> args.level < Logging.Info,\n                FileLogger(\"debug.log\"),\n            ),\n            EarlyFilteredLogger(\n                args -> Logging.Info <= args.level < Logging.Warn,\n                FileLogger(\"info.log\"),\n            ),\n            EarlyFilteredLogger(\n                args -> Logging.Warn <= args.level,\n                FileLogger(\"warnings_and_errors.log\"),\n            ),\n        )\n    ),\n)\nnothing # hide","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"This logger send all messages to the current global logger and an EarlyFilteredLogger. The EarlyFilteredLogger then drops all messages that doesn't come from the module WebServer and send the remaining ones to a new TeeLogger. This TeeLogger send messages to three EarlyFilteredLoggers that only keep messages of a certain level and send those to FileLoggers corresponding to the level. This means that, in \"debug.log\" there will only be messages that come from WebServer (the first filter) and that have debug log level. Similarly, in \"info.log\" there will only be messages with info log level, and any messages with higher level (warn, error) will end up in \"warnings_and_errors.log\".","category":"page"},{"location":"how-to/filter-messages/#Late-filtering-using-ActiveFilteredLogger","page":"How to filter messages","title":"Late filtering using ActiveFilteredLogger","text":"","category":"section"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"In case of filtering based on level, module, group, and id is not enough it is possible to use an ActiveFilteredLogger, also from the LoggingExtras.jl package. This logger is similar to the EarlyFilteredLogger, with the only difference that the named tuple that the predicate functions is given contains more data, see LoggingExtras.handle_message_args. Here is an example of a logger that filter based on the message string content:","category":"page"},{"location":"how-to/filter-messages/","page":"How to filter messages","title":"How to filter messages","text":"using Logging, LoggingExtras\n\nbegin # hide\nglobal_logger() = current_logger() # hide\nlogger = ActiveFilteredLogger(global_logger()) do args\n    return args.message == \"Hello there!\" || args.message == \"General Kenobi!\"\nend\n\nwith_logger(logger) do\n    @info \"I find your lack of faith disturbing.\"\n    @info \"Hello there!\"\n    @info \"General Kenobi!\"\n    @info \"Power! Unlimited power!\"\nend\nend # hide","category":"page"},{"location":"reference/loggingformats/#LoggingFormats.jl","page":"LoggingFormats.jl","title":"LoggingFormats.jl","text":"","category":"section"},{"location":"reference/loggingformats/","page":"LoggingFormats.jl","title":"LoggingFormats.jl","text":"LoggingFormats.JSON\nLoggingFormats.LogFmt\nLoggingFormats.Truncated","category":"page"},{"location":"reference/loggingformats/#LoggingFormats.JSON","page":"LoggingFormats.jl","title":"LoggingFormats.JSON","text":"JSON\n\nSerialize log messages as JSON.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingformats/#LoggingFormats.LogFmt","page":"LoggingFormats.jl","title":"LoggingFormats.LogFmt","text":"LogFmt\n\nFormat log messages as logfmt.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingformats/#LoggingFormats.Truncated","page":"LoggingFormats.jl","title":"LoggingFormats.Truncated","text":"Truncated\n\nFormat log messages similar to ConsoleLogger, but truncate long messages.\n\n\n\n\n\n","category":"type"},{"location":"how-to/enable-debug/#How-to-enable-@debug-messages","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"","category":"section"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"By default log messages with the debug level (e.g. from @debug) are not visible. This is because the lowest log level accepted by the default ConsoleLogger is Logging.Info – anything below that will be discarded.","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"The simplest way to enable all @debug-level messages is thus to create a new logger that accept also these messages. Here is an example of that:","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"using Logging\n\n# New ConsoleLogger that prints to stderr and accept messages with level >= Logging.Debug\ndebug_logger = ConsoleLogger(stderr, Logging.Debug)\nnothing # hide","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"This new logger can now be used instead of the default one  either locally for a task, or globally, see Working with loggers. Examples:","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"begin # hide\ndebug_logger = ConsoleLogger(stderr, Logging.Debug) # hide\nwith_logger(debug_logger) do # Enable the debug logger locally\n     @debug \"This is visible now!\"\nend\nend # hide\n\nbegin # hide\nold_global_logger = global_logger() # hide\ndebug_logger = ConsoleLogger(stderr, Logging.Debug) # hide\nglobal_logger(debug_logger); # Enable the debug logger globally\nglobal_logger(old_global_logger) # hide\nend # hide\nwith_logger(ConsoleLogger(stderr, Logging.Debug)) do # hide\n@debug \"This is visible now!\"\nend # hide","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"The method described above works for any logger that accept the log level as an argument, however, this is not always the case. An alternative, and more composable, way to enable debug messages is to use message filtering based on the log level. This is described in more detail in How to filter messages, but an example with log level filtering is given here using a MinLevelLogger.","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"MinLevelLogger is a logger that wraps another logger, but only let messages with high enough level pass through to the wrapped logger. In this example we wrap a ConsoleLogger that accept every message (Logging.BelowMinLevel).","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"using Logging, LoggingExtras\n\nbegin # hide\nlogger = MinLevelLogger(\n    ConsoleLogger(stderr, Logging.BelowMinLevel),\n    Logging.Debug,\n)\n\nwith_logger(logger) do\n    @debug \"This is visible!\"\nend\nend # hide","category":"page"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"To selectively enable debug messages from e.g. certain modules or packages, or filtering based on things other than the log level, see How to filter messages.","category":"page"},{"location":"how-to/enable-debug/#JULIA_DEBUG-environment-variable","page":"How to enable @debug messages","title":"JULIA_DEBUG environment variable","text":"","category":"section"},{"location":"how-to/enable-debug/","page":"How to enable @debug messages","title":"How to enable @debug messages","text":"Another \"quick and dirty\" way of enabling debug messages is to make use of the environment variable JULIA_DEBUG (see Logging/Environmental variables). This variable can be set to all, to enable all debug messages, or to one or more module names in a comma separated list, to selectively enable debug messages from certain modules. However, using JULIA_DEBUG does not compose as nicely as using proper log message filtering (see How to filter messages). See for example this issue for some more discussion and information: JuliaLogging/LoggingExtras.jl#20 .","category":"page"},{"location":"reference/miniloggers/#MiniLoggers.jl","page":"MiniLoggers.jl","title":"MiniLoggers.jl","text":"","category":"section"},{"location":"reference/miniloggers/","page":"MiniLoggers.jl","title":"MiniLoggers.jl","text":"Modules = [MiniLoggers]","category":"page"},{"location":"reference/miniloggers/#MiniLoggers.MiniLogger-Tuple{}","page":"MiniLoggers.jl","title":"MiniLoggers.MiniLogger","text":"MiniLogger(; <keyword arguments>)\n\nMiniLogger constructor creates custom logger which can be used with usual @info, @debug commands.\n\nSupported keyword arguments include:\n\nio (default stdout): IO stream which is used to output log messages below errlevel level. Can be either IO or String, in the latter case it is treated as a name of the output file.\nioerr (default stderr): IO stream which is used to output log messages above errlevel level. Can be either IO or String, in the latter case it is treated as a name of the output file.\nerrlevel (default Error): determines which output IO to use for log messages. If you want for all messages to go to io, set this parameter to MiniLoggers.AboveMaxLevel. If you want for all messages to go to ioerr, set this parameter to MiniLoggers.BelowMinLevel.\nminlevel (default: Info): messages below this level are ignored. For example with default setting @debug \"foo\" is ignored.\nappend (default: false): defines whether to append to output stream or to truncate file initially. Used only if io or ioerr is a file path.\nmessage_mode (default: :squash): choose how message is transformed before being printed out. Following modes are supported:\n:notransformations: message printed out as is, without any extra transformations\n:squash: message is squashed to a single line, i.e. all \\n are changed to squash_delimiter and \\r are removed.\n:fullsquash: all messages including error stacktraces are squashed to a single line, i.e. all \\n are changed to squash_delimiter and \\r are removed\n:markdown: message is treated as if it is written in markdown\nsquash_delimiter: (default: \"\\t\"): defines which delimiter to use in squash mode.\nflush (default: true): whether to flush IO stream for each log message. Flush behaviour also affected by flush_threshold argument.\nflush_threshold::Union{Integer, TimePeriod} (default: 0): if this argument is nonzero and flush is true, then io is flushed only once per flush_threshold milliseconds. I.e. if time between two consecutive log messages is less then flush_threshold, then second message is not flushed and will have to wait for the next log event.\ndtformat (default: \"yyyy-mm-dd HH:MM:SS\"): if datetime parameter is used in format argument, this dateformat is applied for output timestamps.\nformat (default: \"[{timestamp:func}] {level:func}: {message}\"): format for output log message. It accepts following keywords, which should be provided in curly brackets:\ntimestamp: timestamp of the log message\nlevel: name of log level (Debug, Info, etc)\nfilepath: filepath of the file, which produced log message\nbasename: basename of the filepath of the file, which produced log message\nline: line number of the log command in the file, which produced log message\ngroup: log group \nmodule: name of the module, which contains log command\nid: log message id\nmessage: message itself\n\nEach keyword accepts color information, which should be added after colon inside curly brackets. Colors can be either from Base.text_colors or special keyword func, in which case is used automated coloring. Additionaly, bold modifier is accepted by the format argument. For example: {line:red}, {module:cyan:bold}, {group:func} are all valid parts of the format command.\n\nColour information is applied recursively without override, so {{line} {module:cyan} {group}:red} is equivalent to {line:red} {module:cyan} {group:red}.\n\nIf part of the format is not a recognised keyword, then it is just used as is, for example {foo:red} means that output log message contain word \"foo\" printed in red.\n\n\n\n\n\n","category":"method"},{"location":"reference/progresslogging/#ProgressLogging.jl","page":"ProgressLogging.jl","title":"ProgressLogging.jl","text":"","category":"section"},{"location":"reference/progresslogging/","page":"ProgressLogging.jl","title":"ProgressLogging.jl","text":"Modules = [ProgressLogging]","category":"page"},{"location":"reference/progresslogging/#ProgressLogging.ProgressLogging","page":"ProgressLogging.jl","title":"ProgressLogging.ProgressLogging","text":"ProgressLogging: a package for defining progress logs\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: Coveralls)\n\nProgressLogging.jl is a package for defining progress logs.  It can be used to report progress of a loop/loops with time-consuming body:\n\njulia> using ProgressLogging\n\njulia> @progress for i in 1:10\n           sleep(0.1)\n       end\n\nThis package does not contain any progress monitors for visualizing the progress of the program.  You need to install a package supporting progress logs created by ProgressLogging.jl API.  For example:\n\nJuno\nTerminalLoggers.jl\n\n\n\n\n\n","category":"module"},{"location":"reference/progresslogging/#ProgressLogging.ROOTID","page":"ProgressLogging.jl","title":"ProgressLogging.ROOTID","text":"ProgressLogging.ROOTID\n\nThis is used as parentid of root Progresses.\n\n\n\n\n\n","category":"constant"},{"location":"reference/progresslogging/#ProgressLogging.Progress","page":"ProgressLogging.jl","title":"ProgressLogging.Progress","text":"ProgressLogging.Progress(id, [fraction]; [parentid, name, done])\n\nUsage: Progress log record provider\n\nProgress log record can be created by using the following pattern\n\nid = uuid4()\ntry\n    @info Progress(id)  # create a progress bar\n    # some time consuming job\n    # ...\n    @info Progress(id, 0.1)  # update progress to 10%\n    # ...\nfinally\n    @info Progress(id, done = true)  # close the progress bar\nend\n\nIt is recommended to use @withprogress, @logprogress, and optionally @progressid to create log records.\n\nUsage: Progress log record consumer (aka progress monitor)\n\nIt is recommended to use ProgressLogging.asprogress instead of checking message isa Progress.  Progress monitors can retrieve progress-related information from the following properties.\n\nProperties\n\nfraction::Union{Float64,Nothing}: it can take following values:\n0 <= fraction < 1\nfraction >= 1: completed\nfraction = nothing: indeterminate progress\nid::UUID: Identifier of the job whose progress is at fraction.\nparentid::UUID: The ID of the parent progress.  It is set to ProgressLogging.ROOTID when there is no parent progress. This is used for representing progresses of nested jobs.  Note that sub-jobs may be executed concurrently; i.e., there can be multiple child jobs for one parent job.\nname::String: Name of the progress bar.\ndone::Bool: true if the job is done.\n\n\n\n\n\n","category":"type"},{"location":"reference/progresslogging/#ProgressLogging.asprogress-Tuple{Any, ProgressLogging.Progress, Vararg{Any}}","page":"ProgressLogging.jl","title":"ProgressLogging.asprogress","text":"ProgressLogging.asprogress(_, name, _, _, id, _, _; progress, ...) :: Union{Progress, Nothing}\n\nPre-process log record to obtain a Progress object if it is one of the supported format.  This is mean to be used with the message positional argument and all keyword arguments passed to Logging.handle_message.  Example:\n\nfunction Logging.handle_message(logger::MyLogger, args...; kwargs...)\n    progress = ProgressLogging.asprogress(args...; kwargs...)\n    if progress !== nothing\n        return # handle progress log record\n    end\n    # handle normal log record\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/progresslogging/#ProgressLogging.progress-Tuple{Any}","page":"ProgressLogging.jl","title":"ProgressLogging.progress","text":"progress(f::Function; name = \"\")\n\nEvaluates f with id as its argument and makes sure to destroy the progress bar afterwards. To update the progress bar in f you can call a logging statement like @info or even just @logmsg with _id=id and progress as arguments.\n\nprogress can take either of the following values:\n\n0 <= progress < 1: create or update progress bar\nprogress == nothing || progress = NaN: set progress bar to indeterminate progress\nprogress >= 1 || progress == \"done\": destroy progress bar\n\nThe logging message (e.g. \"foo\" in @info \"foo\") will be used as the progress bar's name.\n\nLog level must be higher or equal to LogLevel(-1).\n\nProgressLogging.progress() do id\n    for i = 1:10\n        sleep(0.5)\n        @info \"iterating\" progress=i/10 _id=id\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/progresslogging/#ProgressLogging.@logprogress","page":"ProgressLogging.jl","title":"ProgressLogging.@logprogress","text":"@logprogress [name] progress [key1=val1 [key2=val2 ...]]\n\nThis macro must be used inside @withprogress macro.\n\nLog a progress event with a value progress.  The expression progress must be evaluated to be a real number between 0 and 1 (inclusive), a NaN, or a string \"done\".\n\nOptional first argument name can be used to change the name of the progress bar.  Additional keyword arguments are passed to @logmsg.\n\n\n\n\n\n","category":"macro"},{"location":"reference/progresslogging/#ProgressLogging.@progress-Tuple","page":"ProgressLogging.jl","title":"ProgressLogging.@progress","text":"@progress [name=\"\", threshold=0.005] for i = ..., j = ..., ...\n@progress [name=\"\", threshold=0.005] x = [... for i = ..., j = ..., ...]\n\nShow a progress meter named name for the given loop or array comprehension if possible. Update frequency is limited by threshold (one update per 0.5% of progress by default).\n\n\n\n\n\n","category":"macro"},{"location":"reference/progresslogging/#ProgressLogging.@progressid-Tuple{}","page":"ProgressLogging.jl","title":"ProgressLogging.@progressid","text":"@progressid\n\nGet the progress ID of current lexical scope.\n\n\n\n\n\n","category":"macro"},{"location":"reference/progresslogging/#ProgressLogging.@withprogress-Tuple","page":"ProgressLogging.jl","title":"ProgressLogging.@withprogress","text":"@withprogress [name=\"\"] [parentid=uuid4()] ex\n\nCreate a lexical environment in which @logprogress can be used to emit progress log events without manually specifying the log level, _id, and name (log message).\n\n@withprogress name=\"iterating\" begin\n    for i = 1:10\n        sleep(0.5)\n        @logprogress i/10\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/loggingextras/#LoggingExtras.jl","page":"LoggingExtras.jl","title":"LoggingExtras.jl","text":"","category":"section"},{"location":"reference/loggingextras/","page":"LoggingExtras.jl","title":"LoggingExtras.jl","text":"Modules = [LoggingExtras]","category":"page"},{"location":"reference/loggingextras/#LoggingExtras.ActiveFilteredLogger","page":"LoggingExtras.jl","title":"LoggingExtras.ActiveFilteredLogger","text":"ActiveFilteredLogger(filter, logger)\n\nWraps logger in an active filter. While loggers intrinsictally have in built filtering mechanisms. Wrapping it in a ActiveFilterLogger allows for extract control, at the cost of a bit of overhead.\n\nThe ActiveFilteredLogger has full control of what is logged, as it sees the full message, this does mean however it determines what to log at runtime, which is the source of the overhead. The EarlyFilteredLogger has less control, but decides if to log before the message is computed.\n\nThe filter should be a function that returns a boolean. true if the message should be logged and false if not. As input it will be given a named tuple with the following fields: (level, message, _module, group, id, file, line, kwargs) See LoggingExtras.handle_message_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.DatetimeRotatingFileLogger","page":"LoggingExtras.jl","title":"LoggingExtras.DatetimeRotatingFileLogger","text":"DatetimeRotatingFileLogger(dir, file_pattern; always_flush=true, rotation_callback=identity)\nDatetimeRotatingFileLogger(f::Function, dir, file_pattern; always_flush=true, rotation_callback=identity)\n\nConstruct a DatetimeRotatingFileLogger that rotates its file based on the current date. The constructor takes a log output directory, dir, and a filename pattern. The smallest time resolution in the format string determines the frequency of log file rotation, allowing for yearly all the way down to minute-level log rotation.\n\nThe pattern can be given as a string or as a Dates.DateFormat. Note that if you wish to have a filename portion that should not be interpreted as a format string, you may need to escape portions of the filename, as shown in the example below.\n\nIt is possible to pass a formatter function as the first argument to control the output. The formatting function should be of the form f(io::IOContext, log_args::NamedTuple) where log_args has the following fields: (level, message, _module, group, id, file, line, kwargs). See LoggingExtras.handle_message_args for more information about what each field represents.\n\nIt is also possible to pass rotation_callback::Function as a keyword argument. This function will be called every time a file rotation is happening. The function should accept one argument which is the absolute path to the just-rotated file. The logger will block until the callback function returns. Use @async if the callback is expensive.\n\nExamples\n\n# Logger that logs to a new file every day\nlogger = DatetimeRotatingFileLogger(log_dir, raw\"\\a\\c\\c\\e\\s\\s-yyyy-mm-dd.\\l\\o\\g\")\n\n# Logger with a formatter function that rotates the log file hourly\nlogger = DatetimeRotatingFileLogger(log_dir, raw\"yyyy-mm-dd-HH.\\l\\o\\g\") do io, args\n    println(io, args.level, \" | \", args.message)\nend\n\n# Example callback function to compress the recently-closed file\ncompressor(file) = run(`gzip $(file)`)\nlogger = DatetimeRotatingFileLogger(...; rotation_callback=compressor)\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.EarlyFilteredLogger","page":"LoggingExtras.jl","title":"LoggingExtras.EarlyFilteredLogger","text":"EarlyFilteredLogger(filter, logger)\n\nWraps logger in an filter that runs before the log message is created.\n\nFor contrast see the ActiveFilteredLogger which has full control, but runs after the log message content is computed. In most circumstances this is fine, but if your log messages are expensive to create (e.g. they include summary statistics), then the EarlyFilteredLogger is going to be better.\n\nThe filter should be a function that returns a boolean. true if the message should be logged and false if not. As input it will be given a named tuple with the following fields: (level, _module, group, id) See LoggingExtras.shouldlog_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.FileLogger-Tuple{Any}","page":"LoggingExtras.jl","title":"LoggingExtras.FileLogger","text":"FileLogger(path::AbstractString; append=false, always_flush=true)\n\nCreate a logger sink that write messages to a file specified with path. To append to the file (rather than truncating the file first), use append=true. If always_flush=true the stream is flushed after every handled log message.\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.FileLogger-Tuple{IOStream}","page":"LoggingExtras.jl","title":"LoggingExtras.FileLogger","text":"FileLogger(io::IOStream; always_flush=true)\n\nCreate a logger sink that write messages to the io::IOStream. The stream is expected to be open and writeable. If always_flush=true the stream is flushed after every handled log message.\n\nExamples\n\nio = open(\"path/to/file.log\", \"a\") # append to the file\nlogger = FileLogger(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.FormatLogger","page":"LoggingExtras.jl","title":"LoggingExtras.FormatLogger","text":"FormatLogger(f::Function, io::IO=stderr; always_flush=true)\n\nLogger sink that formats the message and finally writes to io. The formatting function should be of the form f(io::IOContext, log_args::NamedTuple) where log_args has the following fields: (level, message, _module, group, id, file, line, kwargs). See LoggingExtras.handle_message_args for more information on what field is.\n\nExamples\n\njulia> using Logging, LoggingExtras\n\njulia> logger = FormatLogger() do io, args\n           println(io, args._module, \" | \", \"[\", args.level, \"] \", args.message)\n       end;\n\njulia> with_logger(logger) do\n           @info \"This is an informational message.\"\n           @warn \"This is a warning, should take a look.\"\n       end\nMain | [Info] This is an informational message.\nMain | [Warn] This is a warning, should take a look.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.MinLevelLogger","page":"LoggingExtras.jl","title":"LoggingExtras.MinLevelLogger","text":"MinLevelLogger(logger, min_enabled_level)\n\nWraps logger in an filter that runs before the log message is created. In many ways this is just a specialised EarlyFilteredLogger that only checks the level. This filter only allowed messages on or above the min_enabled_level to pass.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.TeeLogger-Tuple{Vararg{Base.CoreLogging.AbstractLogger}}","page":"LoggingExtras.jl","title":"LoggingExtras.TeeLogger","text":"TeeLogger(loggers...)\n\nSend the same log message to all the loggers.\n\nTo include the current logger do: TeeLogger(current_logger(), loggers...) to include the global logger, do: TeeLogger(global_logger(), loggers...)\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.TransformerLogger","page":"LoggingExtras.jl","title":"LoggingExtras.TransformerLogger","text":"TransformerLogger(f, logger)\n\nPreprocesses log messages, using the function f, before passing them to the logger that is wrapped. This can be used, for example, to truncate a log message. to conditionally change the log level of logs from a given module (which depending on the wrappped logger, might cause the message to be dropped).\n\nThe transforming function f is given a named tuple with the fields: (level, message, _module, group, id, file, line, kwargs) and should return the same. See LoggingExtras.handle_message_args for more information on what each is.\n\n\n\n\n\n","category":"type"},{"location":"reference/loggingextras/#LoggingExtras.handle_message_args-Tuple","page":"LoggingExtras.jl","title":"LoggingExtras.handle_message_args","text":"handle_message_args\n\nThis creates NamedTuple containing all the arguments the logger gives to handle_message It is the type pased to the active logger filter. These argument come from the logging macro (@info,@warn` etc).\n\nlevel::LogLevel Warn, Info, etc,\nmessage::String the message to be logged\n_module::Module can be used to specify a different originating module from the source location of the message.\ngroup::Symbol can be used to override the message group (this is normally derived from the base name of the source file).\nid::Symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\nfile::String and line::Int can be used to override the apparent source location of a log message.\nkwargs...: Any  keyword or position arguments passed to the logging macro\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.next_datetime_transition-Tuple{Dates.DateFormat}","page":"LoggingExtras.jl","title":"LoggingExtras.next_datetime_transition","text":"next_datetime_transition(fmt::DateFormat)\n\nGiven a DateFormat that is being applied to our filename, what is the next time at which our filepath will need to change?\n\n\n\n\n\n","category":"method"},{"location":"reference/loggingextras/#LoggingExtras.shouldlog_args-Tuple","page":"LoggingExtras.jl","title":"LoggingExtras.shouldlog_args","text":"shouldlog_args\n\nThis returns a NamedTuple containing all the arguments the logger gives to shouldlog It is passed to the early logger filter. These argument come from the logging macro (@info, @warn etc).\n\nlevel::LogLevel Warn, Info, etc,\n_module::Module can be used to specify a different originating module from the source location of the message.\ngroup::Symbol can be used to override the message group (this is normally derived from the base name of the source file).\nid::Symbol can be used to override the automatically generated unique message identifier.  This is useful if you need to very closely associate messages generated on different source lines.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/logging-basics/#Logging-basics","page":"Logging basics","title":"Logging basics","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"In this tutorial we will learn the basics of how to emit log messages or log events. We will also learn a bit about what information each message consists of and what happens after the log message is emitted. If you are writing a script or a package this section should cover everything you need.","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"tip: Tip\nIt is a good idea to follow along by copy-pasting the code snippets into a Julia REPL!","category":"page"},{"location":"tutorials/logging-basics/#Basic-log-events","page":"Logging basics","title":"Basic log events","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"The most important information in a log event is the log message and the log level. The log message is usually an informative text string and the log level is a severity level indicating to the reader how important the log message is. Julia's Base module, which is available by default, provides the logging macros @info, @warn, @error, and @debug for creating log messages. These correspond to common log message levels:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"Info: useful information but nothing critical\nWarning: information about something that might not be right\nError: information about something that went wrong\nDebug: extra information useful when debugging","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"Let's look at how we can create some log messages using the macros mentioned above:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"@info \"This is an info message, carry on as usual.\"\n@warn \"This is a warning message, something might be wrong?\"\n@error \"This is an error message, something is not working as it should!\"\n@debug \"This is a debug message, it is invisible!\"\nprintstyled(\"\\njulia>\"; color=:green, bold=true) # hide","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"As you can see, for simple usage we only need the macro, which determines the log level, and the message string. The default logging backend, responsible for handling the log messages that we generate, prints a formatted, colored, message to the terminal as in the example above. The formatting is different depending on the log level: @info-messages don't print out location info (module, file, line number) like @warn- and @error- messages does. You can also note that @debug-messages are off by default. Typically you would only turn on those when you need more information such as when debugging an issue with your code.","category":"page"},{"location":"tutorials/logging-basics/#Adding-extra-metadata-to-the-log-event","page":"Logging basics","title":"Adding extra metadata to the log event","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"In the examples above the only information we passed to the logging macros where the log message string. It is possible to pass along more information by attaching additional things after the message string. Extra information can be added using key = value syntax like this:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"@info \"hello, world\" x = [1, 2, 3] y = \"something else\"","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"or by just attaching a variable like this:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"x = [3, 4, 5];\n@info \"hello, world\" x","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"In both cases you can see that the logging backend formatted the extra information nicely below the log message string. Adding extra information can be useful in many cases, and in particular if you want to keep the message string constant while still passing some dynamic information.","category":"page"},{"location":"tutorials/logging-basics/#Log-levels","page":"Logging basics","title":"Log levels","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"The four logging levels Info, Warn, Error, and Debug are just aliases for specific numeric levels on the allowed log level range as you can see in the table below:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"Level Alias Comment\n-1000001 Logging.BelowMinLevel (below) lowest possible level\n-1000 Logging.Debug log level for @debug messages\n0 Logging.Info log level for @info messages\n1000 Logging.Warn log level for @warn messages\n2000 Logging.Error log level for @error messages\n1000001 Logging.AboveMaxLevel (above) highest possible level","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"The Logging module, which comes with Julia, provides the @logmsg macro, which is a generalization of the other macros mentioned so far. In addition to the message string it is also required to pass a log level to when using this macro, but other than that @logmsg works the same. Here are some examples:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"using Logging\n@logmsg Logging.Info \"Info message from @logmsg.\"\n@logmsg Logging.Error \"Error message from @logmsg.\" x = [1, 2, 3]","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"With the @logmsg macro it is also possible to create log messages with any level using the LogLevel constructor:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"@logmsg Logging.LogLevel(123) \"Log message with log level 123.\"\n@logmsg Logging.LogLevel(1234) \"Log message with log level 1234.\"\n@logmsg Logging.LogLevel(2345) \"Log message with log level 2345.\"","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"From the coloring of the output we can deduce that log level 123 is a Info-message, log level 1234 is a Warn-message, and log level 2345 is a Error-message. You can also see this with the help of the table above: a log message with level X is a:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"debug message if Logging.Debug <= X < Logging.Info,\ninfo message if Logging.Info <= X < Logging.Warn,\nwarn message if Logging.Warn <= X < Logging.Error,\nerror message if Logging.Error <= X < Logging.AboveMaxLevel.","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"Custom log level like this is not very common, but sometimes it is handy with some more fine grained control.","category":"page"},{"location":"tutorials/logging-basics/#Location-metadata","page":"Logging basics","title":"Location metadata","text":"","category":"section"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"In the logging output above you see some other metadata attached to the message. In particular, the source module, the filename and line number of the log event is displayed. Since the code is running in the Julia REPL the module is Main, the \"file\" is REPL[..] and the line simply 1. Every log event generated with the macros mentioned above gets assigned the following metadata:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"the source module,\nthe source file,\nthe source line,\na log event id (unique to the location),\na log event group (the filename by default).","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"It is up to the log message backend to choose what to do with this information. For example, the default logger backend in the Julia REPL shows no metadata for @info messages, and only shows the module, file, and line for other messages. It is possible to override the default, for example to change the apparent source location. To do this you would pass keyword arguments to the log message macros:","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"@warn \"Overriding the source module\" _module = Base\n@warn \"Overriding the source file\" _file = \"example.jl\"\n@warn \"Overriding the source line\" _line = 123\n@warn \"Overriding the log event group\" _group = :example\n@warn \"Overriding the log event id\" _id = :id","category":"page"},{"location":"tutorials/logging-basics/","page":"Logging basics","title":"Logging basics","text":"Since the default logger backend only shows the module, file, and line the other overrides are not visible.","category":"page"},{"location":"reference/lokilogger/#LokiLogger.jl","page":"LokiLogger.jl","title":"LokiLogger.jl","text":"","category":"section"},{"location":"reference/lokilogger/","page":"LokiLogger.jl","title":"LokiLogger.jl","text":"Modules = [LokiLogger]","category":"page"},{"location":"reference/lokilogger/#LokiLogger.Logger","page":"LokiLogger.jl","title":"LokiLogger.Logger","text":"LokiLogger.Logger(server::Union{String,URI}; labels::Dict)\nLokiLogger.Logger(fmt::Function, server::Union{String,URI}; labels::Dict)\n\nCreate a logger that send messages to a Loki server.\n\nThe log messages are attributed with the labels given in the labels dictionary. If no labels are specified the default labels are:\n\n\"host\" => gethostname()\n\"app\"  => \"LokiLogger.jl\"\n\nThe fmt argument is used for formatting. There are two builtin formatting functions:\n\nLokiLogger.logfmt (default): formats the log message in the logfmt format,\nLokiLogger.json: formats the log message as JSON.\n\nCustom functions must take two arguments: an io::IO to write the message to, and args::NamedTuple that contains all the logger arguments, see help for LoggingExtras.handle_message_args for details.\n\nExamples\n\n# Create a logger with a single label and default (logfmt) formatting\nlogger = LokiLogger.Logger(\"http://localhost:3100\"; labels = Dict(\"app\" => \"myapp\"))\n\n# Create a logger with json output formatting\nlogger = LokiLogger.Logger(LokiLogger.json, \"http://localhost:3100\")\n\n# Create a logger with custom formatting\nlogger = LokiLogger.Logger(\"http://localhost:3100\") do io, args\n    # Only output the level and the message\n    print(io, args.level, \": \", args.message)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/lokilogger/#LokiLogger.json-Tuple{IO, Any}","page":"LokiLogger.jl","title":"LokiLogger.json","text":"json(io::IO, args)\n\nFormat the log message as JSON and write to io.\n\nExample logline:\n\n{\"level\":\"info\",\"msg\":\"hello, world\",\"module\":\"Main\",\"file\":\"/run.jl\",\"line\":2,\"group\":\"run\",\"id\":\"Main_6972c827\"}\n\n\n\n\n\n","category":"method"},{"location":"reference/lokilogger/#LokiLogger.logfmt-Tuple{IO, Any}","page":"LokiLogger.jl","title":"LokiLogger.logfmt","text":"logfmt(io::IO, args)\n\nFormat the log message in logfmt key-value format and print to io.\n\nExample logline:\n\nlevel=info msg=\"hello, world\" module=Main file=\"/run.jl\" line=2 group=run id=Main_6972c827\n\n\n\n\n\n","category":"method"},{"location":"#Welcome-to-JuliaLogging!","page":"Home","title":"Welcome to JuliaLogging!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the landing page of the JuliaLogging GitHub organization. JuliaLogging is an umbrella organization for logging-related packages and repositories in the Julia programming language ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aim of this document is to be a \"one-stop-shop\" for everything related to logging in Julia. The document is structured as follows[1]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials will teach you the basics of Julia's logging system.\nHow-to guides will guide you through the steps involved in addressing common tasks and use-cases. They are more advanced than tutorials and assume some knowledge of Julia's logging system.\nReference contains technical reference of functions and APIs (e.g. the docstrings). Use this when looking up details.\nBackground and discussion covers some higher level topics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nPlease help improve this documentation – if something confuses you, chances are you're not alone. It's easy to do as you read along: just click on the \"Edit on GitHub\" link at the top of each page, and then edit the files directly in your browser. Your changes will be vetted by developers before becoming permanent, so don't worry about whether you might say something wrong.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: The organization of the document follows the Diátaxis Framework.","category":"page"},{"location":"how-to/log-to-file/#How-to-log-to-a-file","page":"How to log to a file","title":"How to log to a file","text":"","category":"section"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"tip: Tip\nIt is a good idea to follow along by copy-pasting the code snippets into a Julia REPL!","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"Instead of logging to the terminal it is quite common to send log messages to a log file. Both the ConsoleLogger and the SimpleLogger from the Logging standard library accept an IO stream as input, so it is pretty easy to plug an open filestream in those loggers and log to a file. Here is an example:","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"using Logging\n\nio = open(\"logfile.txt\", \"w\")\nlogger = ConsoleLogger(io)\n\nwith_logger(logger) do\n    @info \"Message to the logfile\"\nend\n\nclose(io)","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"When reading the file and printing the result we can verify that the file contains the expected log output:","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"print(read(\"logfile.txt\", String))\nrm(\"logfile.txt\") # hide","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"With this approach you might notice that, due to IO buffering the messages will be written to the file with a delay, or possibly not until the program ends and the file is closed. In addition it is somewhat annoying to manage the file IO stream yourself like in the example above. Because of these reasons it is often better to use a logger that are implemented specifically for file-writing.","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"The LoggingExtras.jl package provide the FileLogger, and, as the name suggest, this is implemented specifically for writing messages to a file. The FileLogger opens the file and automatically flushes the stream after handling each messages. Here is an example of using the FileLogger:","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"using Logging, LoggingExtras\n\nlogger = FileLogger(\"logfile.txt\")\n\nwith_logger(logger) do\n    @info \"First message to the FileLogger!\"\nend","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"Reading and printing the content:","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"print(read(\"logfile.txt\", String))","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"By default, when the FileLogger opens the file stream it uses \"write\" mode (see documentation for open), which means that if the file exist and have some content this will be overwritten. There is an option to use \"append\" mode by passing append = true to the constructor. This will preserve content in the file and only append at the end. Here is an example of that where we open the same file from above, but use append = true:","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"\nlogger = FileLogger(\"logfile.txt\"; append = true)\n\nwith_logger(logger) do\n    @info \"Second message to the FileLogger?\"\nend\n\nprint(read(\"logfile.txt\", String))\nrm(\"logfile.txt\") # hide","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"As you can see, the first message is still in the file, and we only appended a second one.","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"The FileLogger uses a SimpleLogger internally, so the output formatting is the same as the SimpleLogger. If you want to control the output formatting you can use a FormatLogger (also from LoggingExtras.jl) instead. The FormatLogger accepts a formatting function as the first argument. The formatting function takes two arguments: (i) an IO stream to write the formatted message to and (ii) the logging arguments (see LoggingExtras.handle_message_args). Here is an example:","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"using Logging, LoggingExtras\n\nlogger = FormatLogger(open(\"logfile.txt\", \"w\")) do io, args\n    # Write the module, level and message only\n    println(io, args._module, \" | \", \"[\", args.level, \"] \", args.message)\nend\n\nwith_logger(logger) do\n    @info \"Info message to the FormatLogger!\"\n    @warn \"Warning message to the FormatLogger!\"\nend\n\nprint(read(\"logfile.txt\", String))\nrm(\"logfile.txt\") # hide","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"With the FormatLogger we need to open the file stream manually with the preferred option (\"w\", \"a\", etc) but, just like the FileLogger, it flushes the stream after every message.","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"See also:","category":"page"},{"location":"how-to/log-to-file/","page":"How to log to a file","title":"How to log to a file","text":"Send messages to multiple locations for how to send log messages to multiple loggers, for example to a file and to the terminal.\nHow to rotate log files for more file logging options.","category":"page"},{"location":"tutorials/implement-a-new-logger/#Implement-a-new-logger","page":"Implement a new logger","title":"Implement a new logger","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"In this tutorial we will go through the necessary steps for implementing a new logger. This includes defining a new struct, which is a subtype of Logging.AbstractLogger, and implementing the necessary method for the logger interface.","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"note: Note\nIn general, unless you are implementing a new logger sink, there should be no need to define a new logger to get the behavior you want. The LoggingExtras.jl package provide loggers for arbitrary routing, transforming, and filtering of log events. For example, the logger implemented in this example is trivial to achieve using a TransformerLogger (see the last section of this page).","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"As a toy example we will implement a cipher logger – a logger that \"encrypts\" the message using a Caesar cipher. We want the logger to accept any log event, and be configurable with an output stream. Let's get started!","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"tip: Tip\nIt is a good idea to follow along by copy-pasting the code snippets into a Julia REPL!","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"The first step is to load the Logging.jl stdlib which defines the logging infrastructure and the necessary methods that we need to extend for our new logger. After that we define the new logger struct, and make sure to use Logging.AbstractLogger as the supertype:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"using Logging\n\nstruct CipherLogger <: Logging.AbstractLogger\n    io::IO\n    key::Int\nend\n\nCipherLogger(key::Int=3) = CipherLogger(stderr, key)","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Input to the logger struct is the I/O stream to which all messages will be written, and the cipher key, which, for the Caesar cipher, is just an integer. An outer convenience struct is also defined with some default values: stderr for the I/O stream and 3 for the key.","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Next we need to extend the required methods for our new CipherLogger:","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.min_enabled_level](@ref)","page":"Implement a new logger","title":"Logging.min_enabled_level","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"This method should return the minimum level for which the logger accepts messages. The default logger in the Julia REPL only accepts message with level Logging.Info or higher, for example. We want our logger to accept everything, so we simply return Logging.BelowMinLevel, which is the smallest possible level:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Logging.min_enabled_level(logger::CipherLogger) = Logging.BelowMinLevel","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.shouldlog](@ref)","page":"Implement a new logger","title":"Logging.shouldlog","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"This method is the next chance to filter log messages. The input arguments are the logger, the log message level, the module where the log event was created, a \"group\" which is (by default) the filename in which the log event was created, and a log event id which is a unique identifier of the location where the event was created. Based on this information we can decide whether the logger should accept the message and return true, or if it should reject the message and return false. Again, since we want our logger to accept everything we simply return true regardless of the input:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"function Logging.shouldlog(logger::CipherLogger, level, _module, group, id)\n   return true\nend","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.catch_exceptions](@ref)","page":"Implement a new logger","title":"Logging.catch_exceptions","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"This method decide whether or not our logger should catch exceptions originating from the logging system. This can, for example, happen when generating the log message. If catch_exceptions returns true the logging system will send a log message to the logger about the error, and otherwise not. Let's accept those error log messages:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Logging.catch_exceptions(logger::CipherLogger) = true","category":"page"},{"location":"tutorials/implement-a-new-logger/#[Logging.handle_message](@ref)","page":"Implement a new logger","title":"Logging.handle_message","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"This method is where the log event is finally arriving at. The input arguments are the logger, the log level, the message, and metadata about the source location of the message (module, group, id, file, and line). In addition, there might be keyword arguments attached to the log event. For example, from the following:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"@info \"hello, world\" time = time()","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"the logger would be sent the keyword argument time => time() (see the tutorial on Logging basics for more details). Based on this information we will now generate a log message and, for our logger, print it to the loggers I/O stream. Of course, in general this method doesn't  have to write to a regular stream, it could for example send the log event as an HTTP request (like the LokiLogger.jl package), or send it as a message to your phone. The handle_message function for our CipherLogger below is very simple: we apply the cipher to the message, and then write out the level and the encrypted message:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"function Logging.handle_message(logger::CipherLogger,\n                                lvl, msg, _mod, group, id, file, line;\n                                kwargs...)\n    # Apply Ceasar cipher on the log message\n    msg = caesar(msg, logger.key)\n    # Write the formatted log message to logger.io\n    println(logger.io, \"[\", lvl, \"] \", msg)\nend","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"The only missing part is now the caesar function, which should encrypt the message with the key for the logger. The encryption here is only applied to ASCII letters A-Z and a-z:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"function caesar(msg::String, key::Int)\n    io = IOBuffer()\n    for c in msg\n        shift = ('a' <= c <= 'z') ? Int('a') : ('A' <= c <= 'Z') ? Int('A') : 0\n        if shift > 0\n            c = Char((Int(c) - shift + key) % 26 + shift)\n        end\n        print(io, c)\n    end\n    return String(take!(io))\nend","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"That's it – we have implemented a new logger! Let's take it for a spin. If you have been following along, and have copy-pasted the code snippets into a Julia REPL from the start, you should see the same output as below:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"julia> using Logging\n\njulia> cipher_logger = CipherLogger(3); # new logger with 3 as the key\n\njulia> global_logger(cipher_logger); # set the logger as the global logger\n\njulia> @info \"Hello, world!\"\n[Info] Khoor, zruog!\n\njulia> @info \"This is an info message.\"\n[Info] Wklv lv dq lqir phvvdjh.\n\njulia> @warn \"This is a warning.\"\n[Warn] Wklv lv d zduqlqj.\n\njulia> @error \"This is an error message.\"\n[Error] Wklv lv dq huuru phvvdjh.","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"We can also make sure the our logger accepts log events with level lower than Logging.Info (which e.g. the default logger doesn't):","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"julia> @debug \"Is this visible?\"\n[Debug] Lv wklv ylvleoh?","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Finally, lets make sure that the logger also catches log event exceptions. For example, here we try to create a message string with a variable name which is undefined:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"julia> @info \"hello, $name\"\n[Error] Hafhswlrq zkloh jhqhudwlqj orj uhfrug lq prgxoh Pdlq dw UHSO[17]:1","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Can you crack the cipher and understand what that means?","category":"page"},{"location":"tutorials/implement-a-new-logger/#cipher-existing","page":"Implement a new logger","title":"Build CipherLogger using existing functionality","text":"","category":"section"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"As indicated in the beginning of this page, unless you are interfacing a new type of logger sink there is generally no need to implement your own logger. Instead it is better to compose existing loggers for routing, transforming, and filtering log events. The CipherLogger above can trivially be implemented using a TransformerLogger from the LoggingExtras.jl package as follows:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"using Logging, LoggingExtras\n\nencryption_logger = TransformerLogger(SimpleLogger(stderr)) do args\n    message = caesar(args.message, 3)\n    return (; args..., message=message)\nend\n\nglobal_logger(encryption_logger)","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"The result looks as follows:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"julia> @info \"hello, world\"\n┌ Info: khoor, zruog\n└ @ Main REPL[5]:1","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Another advantage of using the already existing TransformerLogger is that it composes nicely. We can therefore decrypt the message with another layer:","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"decryption_logger = TransformerLogger(encryption_logger) do args\n    message = caesar(args.message, -3) # to decrypt just negate the key\n    return (; args..., message=message)\nend\n\nglobal_logger(decryption_logger)","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"Now the messages are encrypted and decrypted before printing to the terminal, so in this case the two loggers just undo each other. Pretty useless, but composability is useful for many other things!","category":"page"},{"location":"tutorials/implement-a-new-logger/","page":"Implement a new logger","title":"Implement a new logger","text":"julia> @info \"hello, world\"\n┌ Info: hello, world\n└ @ Main REPL[8]:1","category":"page"}]
}
